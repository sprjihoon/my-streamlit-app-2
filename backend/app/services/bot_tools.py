"""
ë´‡ Function Calling ë„êµ¬ ì •ì˜
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
OpenAI Function Callingì„ ìœ„í•œ ë„êµ¬(tools) ìŠ¤í‚¤ë§ˆì™€ ì‹¤í–‰ í•¨ìˆ˜ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
"""

import json
from datetime import datetime, timedelta
from typing import Optional, Dict, Any, List
from logic.db import get_connection
from backend.app.api.logs import add_log


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ë„êµ¬(Tools) ìŠ¤í‚¤ë§ˆ ì •ì˜ - OpenAI Function Calling í˜•ì‹
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TOOLS = [
    {
        "type": "function",
        "function": {
            "name": "save_work_log",
            "description": "ì‘ì—…ì¼ì§€ë¥¼ ì €ì¥í•©ë‹ˆë‹¤. ì—…ì²´ëª…, ì‘ì—…ì¢…ë¥˜, ë‹¨ê°€ëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤.",
            "parameters": {
                "type": "object",
                "properties": {
                    "vendor": {
                        "type": "string",
                        "description": "ì—…ì²´ëª… (ì˜ˆ: í‹¸ë¦¬ì–¸, ë‚˜ë¸”ë¦¬)"
                    },
                    "work_type": {
                        "type": "string",
                        "description": "ì‘ì—… ì¢…ë¥˜ (ì˜ˆ: 1í†¤í•˜ì°¨, ì–‘í’ˆí™”, ì…ê³ )"
                    },
                    "unit_price": {
                        "type": "integer",
                        "description": "ë‹¨ê°€ (ì› ë‹¨ìœ„, ì˜ˆ: 30000)"
                    },
                    "qty": {
                        "type": "integer",
                        "description": "ìˆ˜ëŸ‰ (ê¸°ë³¸ê°’: 1)",
                        "default": 1
                    },
                    "date": {
                        "type": "string",
                        "description": "ì‘ì—…ì¼ (YYYY-MM-DD í˜•ì‹, ê¸°ë³¸ê°’: ì˜¤ëŠ˜)"
                    },
                    "remark": {
                        "type": "string",
                        "description": "ë¹„ê³ /ë©”ëª¨"
                    }
                },
                "required": ["vendor", "work_type", "unit_price"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "save_multiple_work_logs",
            "description": "ì—¬ëŸ¬ ì‘ì—…ì¼ì§€ë¥¼ í•œ ë²ˆì— ì €ì¥í•©ë‹ˆë‹¤.",
            "parameters": {
                "type": "object",
                "properties": {
                    "entries": {
                        "type": "array",
                        "description": "ì €ì¥í•  ì‘ì—…ì¼ì§€ ëª©ë¡",
                        "items": {
                            "type": "object",
                            "properties": {
                                "vendor": {"type": "string"},
                                "work_type": {"type": "string"},
                                "unit_price": {"type": "integer"},
                                "qty": {"type": "integer", "default": 1},
                                "date": {"type": "string"},
                                "remark": {"type": "string"}
                            },
                            "required": ["vendor", "work_type", "unit_price"]
                        }
                    }
                },
                "required": ["entries"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "delete_work_log",
            "description": "ì‘ì—…ì¼ì§€ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤. IDë¡œ ì‚­ì œí•˜ê±°ë‚˜, ì¡°ê±´ìœ¼ë¡œ ìµœê·¼ 1ê±´ì„ ì‚­ì œí•©ë‹ˆë‹¤.",
            "parameters": {
                "type": "object",
                "properties": {
                    "log_id": {
                        "type": "integer",
                        "description": "ì‚­ì œí•  ì‘ì—…ì¼ì§€ ID (ì•Œê³  ìˆëŠ” ê²½ìš°)"
                    },
                    "vendor": {
                        "type": "string",
                        "description": "ì—…ì²´ëª… ì¡°ê±´"
                    },
                    "work_type": {
                        "type": "string",
                        "description": "ì‘ì—…ì¢…ë¥˜ ì¡°ê±´"
                    },
                    "date": {
                        "type": "string",
                        "description": "ë‚ ì§œ ì¡°ê±´ (YYYY-MM-DD)"
                    },
                    "price": {
                        "type": "integer",
                        "description": "ê¸ˆì•¡ ì¡°ê±´ (í•©ê³„)"
                    },
                    "delete_recent": {
                        "type": "boolean",
                        "description": "ì‚¬ìš©ìì˜ ê°€ì¥ ìµœê·¼ ì‘ì—…ì¼ì§€ ì‚­ì œ (trueë©´ ë‹¤ë¥¸ ì¡°ê±´ ë¬´ì‹œ)",
                        "default": False
                    }
                }
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "search_work_logs",
            "description": "ì¡°ê±´ì— ë§ëŠ” ì‘ì—…ì¼ì§€ë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤.",
            "parameters": {
                "type": "object",
                "properties": {
                    "vendor": {
                        "type": "string",
                        "description": "ì—…ì²´ëª… (ë¶€ë¶„ ì¼ì¹˜)"
                    },
                    "work_type": {
                        "type": "string",
                        "description": "ì‘ì—…ì¢…ë¥˜ (ë¶€ë¶„ ì¼ì¹˜)"
                    },
                    "date": {
                        "type": "string",
                        "description": "íŠ¹ì • ë‚ ì§œ (YYYY-MM-DD)"
                    },
                    "start_date": {
                        "type": "string",
                        "description": "ì‹œì‘ ë‚ ì§œ (YYYY-MM-DD)"
                    },
                    "end_date": {
                        "type": "string",
                        "description": "ì¢…ë£Œ ë‚ ì§œ (YYYY-MM-DD)"
                    },
                    "price": {
                        "type": "integer",
                        "description": "ê¸ˆì•¡ (Â±10% ë²”ìœ„ë¡œ ê²€ìƒ‰)"
                    },
                    "limit": {
                        "type": "integer",
                        "description": "ìµœëŒ€ ê²°ê³¼ ìˆ˜ (ê¸°ë³¸: 20)",
                        "default": 20
                    }
                }
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "get_work_log_stats",
            "description": "ì‘ì—…ì¼ì§€ í†µê³„ë¥¼ ì¡°íšŒí•©ë‹ˆë‹¤ (ì´ ê±´ìˆ˜, ì´ì•¡, ì—…ì²´ë³„, ì‘ì—…ë³„ í†µê³„).",
            "parameters": {
                "type": "object",
                "properties": {
                    "start_date": {
                        "type": "string",
                        "description": "ì‹œì‘ ë‚ ì§œ (YYYY-MM-DD)"
                    },
                    "end_date": {
                        "type": "string",
                        "description": "ì¢…ë£Œ ë‚ ì§œ (YYYY-MM-DD)"
                    },
                    "vendor": {
                        "type": "string",
                        "description": "íŠ¹ì • ì—…ì²´ë§Œ ì¡°íšŒ"
                    }
                }
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "compare_periods",
            "description": "ë‘ ê¸°ê°„ì˜ ì‘ì—…ì¼ì§€ í†µê³„ë¥¼ ë¹„êµí•©ë‹ˆë‹¤.",
            "parameters": {
                "type": "object",
                "properties": {
                    "period1_start": {
                        "type": "string",
                        "description": "ê¸°ê°„1 ì‹œì‘ì¼ (YYYY-MM-DD)"
                    },
                    "period1_end": {
                        "type": "string",
                        "description": "ê¸°ê°„1 ì¢…ë£Œì¼ (YYYY-MM-DD)"
                    },
                    "period1_name": {
                        "type": "string",
                        "description": "ê¸°ê°„1 ì´ë¦„ (ì˜ˆ: 'ì§€ë‚œì£¼')"
                    },
                    "period2_start": {
                        "type": "string",
                        "description": "ê¸°ê°„2 ì‹œì‘ì¼ (YYYY-MM-DD)"
                    },
                    "period2_end": {
                        "type": "string",
                        "description": "ê¸°ê°„2 ì¢…ë£Œì¼ (YYYY-MM-DD)"
                    },
                    "period2_name": {
                        "type": "string",
                        "description": "ê¸°ê°„2 ì´ë¦„ (ì˜ˆ: 'ì´ë²ˆì£¼')"
                    }
                },
                "required": ["period1_start", "period1_end", "period2_start", "period2_end"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "update_work_log",
            "description": "ì‘ì—…ì¼ì§€ë¥¼ ìˆ˜ì •í•©ë‹ˆë‹¤.",
            "parameters": {
                "type": "object",
                "properties": {
                    "log_id": {
                        "type": "integer",
                        "description": "ìˆ˜ì •í•  ì‘ì—…ì¼ì§€ ID"
                    },
                    "vendor": {
                        "type": "string",
                        "description": "ì—…ì²´ëª… ì¡°ê±´ (ID ëª¨ë¥¼ ë•Œ)"
                    },
                    "date": {
                        "type": "string",
                        "description": "ë‚ ì§œ ì¡°ê±´ (ID ëª¨ë¥¼ ë•Œ)"
                    },
                    "old_price": {
                        "type": "integer",
                        "description": "ê¸°ì¡´ ê¸ˆì•¡ ì¡°ê±´ (ID ëª¨ë¥¼ ë•Œ)"
                    },
                    "new_vendor": {
                        "type": "string",
                        "description": "ìƒˆ ì—…ì²´ëª…"
                    },
                    "new_work_type": {
                        "type": "string",
                        "description": "ìƒˆ ì‘ì—…ì¢…ë¥˜"
                    },
                    "new_unit_price": {
                        "type": "integer",
                        "description": "ìƒˆ ë‹¨ê°€"
                    },
                    "new_qty": {
                        "type": "integer",
                        "description": "ìƒˆ ìˆ˜ëŸ‰"
                    },
                    "update_recent": {
                        "type": "boolean",
                        "description": "ì‚¬ìš©ìì˜ ê°€ì¥ ìµœê·¼ ì‘ì—…ì¼ì§€ ìˆ˜ì • (trueë©´ ì¡°ê±´ ë¬´ì‹œ)",
                        "default": False
                    }
                }
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "bulk_update_work_logs",
            "description": "ì¡°ê±´ì— ë§ëŠ” ì—¬ëŸ¬ ì‘ì—…ì¼ì§€ë¥¼ ì¼ê´„ ìˆ˜ì •í•©ë‹ˆë‹¤.",
            "parameters": {
                "type": "object",
                "properties": {
                    "vendor": {
                        "type": "string",
                        "description": "ì—…ì²´ëª… ì¡°ê±´"
                    },
                    "work_type": {
                        "type": "string",
                        "description": "ì‘ì—…ì¢…ë¥˜ ì¡°ê±´"
                    },
                    "date": {
                        "type": "string",
                        "description": "ë‚ ì§œ ì¡°ê±´"
                    },
                    "start_date": {
                        "type": "string",
                        "description": "ì‹œì‘ ë‚ ì§œ"
                    },
                    "end_date": {
                        "type": "string",
                        "description": "ì¢…ë£Œ ë‚ ì§œ"
                    },
                    "new_unit_price": {
                        "type": "integer",
                        "description": "ìƒˆ ë‹¨ê°€"
                    }
                },
                "required": ["new_unit_price"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "copy_work_logs",
            "description": "ì‘ì—…ì¼ì§€ë¥¼ ë‹¤ë¥¸ ë‚ ì§œë¡œ ë³µì‚¬í•©ë‹ˆë‹¤.",
            "parameters": {
                "type": "object",
                "properties": {
                    "source_date": {
                        "type": "string",
                        "description": "ë³µì‚¬í•  ì›ë³¸ ë‚ ì§œ"
                    },
                    "source_start_date": {
                        "type": "string",
                        "description": "ë³µì‚¬í•  ê¸°ê°„ ì‹œì‘ì¼"
                    },
                    "source_end_date": {
                        "type": "string",
                        "description": "ë³µì‚¬í•  ê¸°ê°„ ì¢…ë£Œì¼"
                    },
                    "vendor": {
                        "type": "string",
                        "description": "íŠ¹ì • ì—…ì²´ë§Œ ë³µì‚¬"
                    },
                    "target_date": {
                        "type": "string",
                        "description": "ë³µì‚¬ ëŒ€ìƒ ë‚ ì§œ (ê¸°ë³¸: ì˜¤ëŠ˜)"
                    }
                }
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "add_memo",
            "description": "ì‘ì—…ì¼ì§€ì— ë©”ëª¨/ë¹„ê³ ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.",
            "parameters": {
                "type": "object",
                "properties": {
                    "log_id": {
                        "type": "integer",
                        "description": "ì‘ì—…ì¼ì§€ ID"
                    },
                    "memo": {
                        "type": "string",
                        "description": "ì¶”ê°€í•  ë©”ëª¨ ë‚´ìš©"
                    },
                    "add_to_recent": {
                        "type": "boolean",
                        "description": "ê°€ì¥ ìµœê·¼ ì‘ì—…ì¼ì§€ì— ì¶”ê°€",
                        "default": False
                    }
                },
                "required": ["memo"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "get_undo_history",
            "description": "ë˜ëŒë¦¬ê¸° ê°€ëŠ¥í•œ ë³€ê²½ ì´ë ¥ì„ ì¡°íšŒí•©ë‹ˆë‹¤.",
            "parameters": {
                "type": "object",
                "properties": {
                    "limit": {
                        "type": "integer",
                        "description": "ì¡°íšŒí•  ì´ë ¥ ìˆ˜ (ê¸°ë³¸: 5)",
                        "default": 5
                    }
                }
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "undo_action",
            "description": "íŠ¹ì • ë³€ê²½ì„ ë˜ëŒë¦½ë‹ˆë‹¤.",
            "parameters": {
                "type": "object",
                "properties": {
                    "history_id": {
                        "type": "integer",
                        "description": "ë˜ëŒë¦´ ì´ë ¥ ID"
                    },
                    "history_index": {
                        "type": "integer",
                        "description": "ë˜ëŒë¦´ ì´ë ¥ ì¸ë±ìŠ¤ (1ë¶€í„° ì‹œì‘, ì‚¬ìš©ìê°€ '1ë²ˆ' ì„ íƒ ì‹œ)"
                    }
                }
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "get_dashboard_url",
            "description": "ëŒ€ì‹œë³´ë“œ/ì›¹í˜ì´ì§€ URLì„ ë°˜í™˜í•©ë‹ˆë‹¤.",
            "parameters": {
                "type": "object",
                "properties": {}
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "web_search",
            "description": "ì›¹ì—ì„œ ì •ë³´ë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤ (ì™¸ë¶€ ì •ë³´ ì¡°íšŒìš©).",
            "parameters": {
                "type": "object",
                "properties": {
                    "query": {
                        "type": "string",
                        "description": "ê²€ìƒ‰ì–´"
                    }
                },
                "required": ["query"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "get_help",
            "description": "ì‚¬ìš©ë²•/ë„ì›€ë§ì„ ë°˜í™˜í•©ë‹ˆë‹¤.",
            "parameters": {
                "type": "object",
                "properties": {
                    "topic": {
                        "type": "string",
                        "description": "ë„ì›€ë§ ì£¼ì œ (ì…ë ¥, ì¡°íšŒ, ìˆ˜ì •, ë¶„ì„, ê³ ê¸‰, ì „ì²´)",
                        "enum": ["ì…ë ¥", "ì¡°íšŒ", "ìˆ˜ì •", "ë¶„ì„", "ê³ ê¸‰", "ì „ì²´"]
                    }
                }
            }
        }
    }
]


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ë„êµ¬ ì‹¤í–‰ í•¨ìˆ˜ë“¤
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def execute_tool(
    tool_name: str,
    arguments: Dict[str, Any],
    user_id: str,
    user_name: str = None
) -> Dict[str, Any]:
    """
    ë„êµ¬ë¥¼ ì‹¤í–‰í•˜ê³  ê²°ê³¼ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    
    Args:
        tool_name: ì‹¤í–‰í•  ë„êµ¬ ì´ë¦„
        arguments: ë„êµ¬ ì¸ì
        user_id: ì‚¬ìš©ì ID
        user_name: ì‚¬ìš©ì ì´ë¦„
    
    Returns:
        ì‹¤í–‰ ê²°ê³¼ ë”•ì…”ë„ˆë¦¬
    """
    tool_functions = {
        "save_work_log": _save_work_log,
        "save_multiple_work_logs": _save_multiple_work_logs,
        "delete_work_log": _delete_work_log,
        "search_work_logs": _search_work_logs,
        "get_work_log_stats": _get_work_log_stats,
        "compare_periods": _compare_periods,
        "update_work_log": _update_work_log,
        "bulk_update_work_logs": _bulk_update_work_logs,
        "copy_work_logs": _copy_work_logs,
        "add_memo": _add_memo,
        "get_undo_history": _get_undo_history,
        "undo_action": _undo_action,
        "get_dashboard_url": _get_dashboard_url,
        "web_search": _web_search,
        "get_help": _get_help,
    }
    
    if tool_name not in tool_functions:
        return {"success": False, "error": f"Unknown tool: {tool_name}"}
    
    try:
        return tool_functions[tool_name](arguments, user_id, user_name)
    except Exception as e:
        return {"success": False, "error": str(e)}


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ê°œë³„ ë„êµ¬ ì‹¤í–‰ í•¨ìˆ˜
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def _save_work_log(args: Dict, user_id: str, user_name: str) -> Dict:
    """ì‘ì—…ì¼ì§€ ì €ì¥"""
    vendor = args.get("vendor", "")
    work_type = args.get("work_type", "")
    unit_price = args.get("unit_price", 0)
    qty = args.get("qty", 1)
    date = args.get("date") or datetime.now().strftime("%Y-%m-%d")
    remark = args.get("remark", "")
    
    if not vendor or not work_type or not unit_price:
        return {"success": False, "error": "ì—…ì²´ëª…, ì‘ì—…ì¢…ë¥˜, ë‹¨ê°€ëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤."}
    
    total = unit_price * qty
    ì €ì¥ì‹œê°„ = datetime.now().isoformat()
    
    with get_connection() as con:
        cursor = con.execute(
            """INSERT INTO work_log 
               (ë‚ ì§œ, ì—…ì²´ëª…, ë¶„ë¥˜, ë‹¨ê°€, ìˆ˜ëŸ‰, í•©ê³„, ë¹„ê³ 1, ì‘ì„±ì, ì €ì¥ì‹œê°„, ì¶œì²˜, works_user_id)
               VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
            (date, vendor, work_type, unit_price, qty, total, remark, user_name, ì €ì¥ì‹œê°„, "bot", user_id)
        )
        con.commit()
        record_id = cursor.lastrowid
    
    # ì´ë ¥ ê¸°ë¡
    _log_work_history(record_id, "create", {
        "ë‚ ì§œ": date, "ì—…ì²´ëª…": vendor, "ë¶„ë¥˜": work_type,
        "ë‹¨ê°€": unit_price, "ìˆ˜ëŸ‰": qty, "í•©ê³„": total, "ì‘ì„±ì": user_name
    }, user_name, "ë´‡ ì…ë ¥", user_id)
    
    # í™œë™ ë¡œê·¸
    add_log(
        action_type="ì‘ì—…ì¼ì§€_ìƒì„±",
        target_type="work_log",
        target_id=str(record_id),
        target_name=f"{vendor} {work_type}",
        user_nickname=user_name or "ë´‡",
        details=f"ë‚ ì§œ: {date}, í•©ê³„: {total:,}ì› (ë´‡ ì…ë ¥)"
    )
    
    return {
        "success": True,
        "record_id": record_id,
        "data": {
            "vendor": vendor,
            "work_type": work_type,
            "qty": qty,
            "unit_price": unit_price,
            "total": total,
            "date": date,
            "remark": remark
        },
        "message": f"ì €ì¥ì™„ë£Œ! {vendor} {work_type} {total:,}ì›"
    }


def _save_multiple_work_logs(args: Dict, user_id: str, user_name: str) -> Dict:
    """ì—¬ëŸ¬ ì‘ì—…ì¼ì§€ ì €ì¥"""
    entries = args.get("entries", [])
    if not entries:
        return {"success": False, "error": "ì €ì¥í•  í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤."}
    
    results = []
    total_saved = 0
    total_amount = 0
    
    for entry in entries:
        result = _save_work_log(entry, user_id, user_name)
        results.append(result)
        if result.get("success"):
            total_saved += 1
            total_amount += result["data"]["total"]
    
    return {
        "success": True,
        "saved_count": total_saved,
        "total_amount": total_amount,
        "results": results,
        "message": f"{total_saved}ê±´ ì €ì¥ì™„ë£Œ! ì´ {total_amount:,}ì›"
    }


def _delete_work_log(args: Dict, user_id: str, user_name: str) -> Dict:
    """ì‘ì—…ì¼ì§€ ì‚­ì œ"""
    log_id = args.get("log_id")
    delete_recent = args.get("delete_recent", False)
    
    with get_connection() as con:
        # ì‚­ì œí•  ë ˆì½”ë“œ ì°¾ê¸°
        if delete_recent:
            row = con.execute(
                """SELECT id, ë‚ ì§œ, ì—…ì²´ëª…, ë¶„ë¥˜, ë‹¨ê°€, ìˆ˜ëŸ‰, í•©ê³„, ì‘ì„±ì
                   FROM work_log WHERE works_user_id = ?
                   ORDER BY id DESC LIMIT 1""",
                (user_id,)
            ).fetchone()
        elif log_id:
            row = con.execute(
                "SELECT id, ë‚ ì§œ, ì—…ì²´ëª…, ë¶„ë¥˜, ë‹¨ê°€, ìˆ˜ëŸ‰, í•©ê³„, ì‘ì„±ì FROM work_log WHERE id = ?",
                (log_id,)
            ).fetchone()
        else:
            # ì¡°ê±´ìœ¼ë¡œ ì°¾ê¸°
            conditions = []
            params = []
            if args.get("vendor"):
                conditions.append("ì—…ì²´ëª… LIKE ?")
                params.append(f"%{args['vendor']}%")
            if args.get("work_type"):
                conditions.append("ë¶„ë¥˜ LIKE ?")
                params.append(f"%{args['work_type']}%")
            if args.get("date"):
                conditions.append("ë‚ ì§œ = ?")
                params.append(args["date"])
            if args.get("price"):
                conditions.append("í•©ê³„ BETWEEN ? AND ?")
                params.extend([int(args["price"] * 0.9), int(args["price"] * 1.1)])
            
            if not conditions:
                return {"success": False, "error": "ì‚­ì œ ì¡°ê±´ì„ ì§€ì •í•´ì£¼ì„¸ìš”."}
            
            # ì‚¬ìš©ì ì œí•œ
            conditions.append("works_user_id = ?")
            params.append(user_id)
            
            row = con.execute(
                f"""SELECT id, ë‚ ì§œ, ì—…ì²´ëª…, ë¶„ë¥˜, ë‹¨ê°€, ìˆ˜ëŸ‰, í•©ê³„, ì‘ì„±ì
                   FROM work_log WHERE {' AND '.join(conditions)}
                   ORDER BY id DESC LIMIT 1""",
                params
            ).fetchone()
        
        if not row:
            return {"success": False, "error": "ì‚­ì œí•  ì‘ì—…ì¼ì§€ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."}
        
        log_id = row[0]
        log_data = {
            "id": row[0], "ë‚ ì§œ": row[1], "ì—…ì²´ëª…": row[2], "ë¶„ë¥˜": row[3],
            "ë‹¨ê°€": row[4], "ìˆ˜ëŸ‰": row[5], "í•©ê³„": row[6], "ì‘ì„±ì": row[7]
        }
        
        # ì´ë ¥ ê¸°ë¡
        _log_work_history(log_id, "delete", log_data, user_name, "ì‚­ì œ", user_id)
        
        # ì‚­ì œ
        con.execute("DELETE FROM work_log WHERE id = ?", (log_id,))
        con.commit()
    
    # í™œë™ ë¡œê·¸
    add_log(
        action_type="ì‘ì—…ì¼ì§€_ì‚­ì œ",
        target_type="work_log",
        target_id=str(log_id),
        target_name=f"{log_data['ì—…ì²´ëª…']} {log_data['ë¶„ë¥˜']}",
        user_nickname=user_name or "ë´‡",
        details=f"ë‚ ì§œ: {log_data['ë‚ ì§œ']}, í•©ê³„: {log_data['í•©ê³„']:,}ì›"
    )
    
    return {
        "success": True,
        "deleted": log_data,
        "message": f"ì‚­ì œì™„ë£Œ! {log_data['ì—…ì²´ëª…']} {log_data['ë¶„ë¥˜']} {log_data['í•©ê³„']:,}ì›"
    }


def _search_work_logs(args: Dict, user_id: str, user_name: str) -> Dict:
    """ì‘ì—…ì¼ì§€ ê²€ìƒ‰"""
    conditions = []
    params = []
    
    if args.get("vendor"):
        conditions.append("ì—…ì²´ëª… LIKE ?")
        params.append(f"%{args['vendor']}%")
    if args.get("work_type"):
        conditions.append("ë¶„ë¥˜ LIKE ?")
        params.append(f"%{args['work_type']}%")
    if args.get("date"):
        conditions.append("ë‚ ì§œ = ?")
        params.append(args["date"])
    elif args.get("start_date") and args.get("end_date"):
        conditions.append("ë‚ ì§œ >= ? AND ë‚ ì§œ <= ?")
        params.extend([args["start_date"], args["end_date"]])
    elif args.get("start_date"):
        conditions.append("ë‚ ì§œ >= ?")
        params.append(args["start_date"])
    elif args.get("end_date"):
        conditions.append("ë‚ ì§œ <= ?")
        params.append(args["end_date"])
    if args.get("price"):
        conditions.append("í•©ê³„ BETWEEN ? AND ?")
        params.extend([int(args["price"] * 0.9), int(args["price"] * 1.1)])
    
    where_clause = " AND ".join(conditions) if conditions else "1=1"
    limit = args.get("limit", 20)
    
    with get_connection() as con:
        rows = con.execute(
            f"""SELECT id, ë‚ ì§œ, ì—…ì²´ëª…, ë¶„ë¥˜, ìˆ˜ëŸ‰, ë‹¨ê°€, í•©ê³„, ì €ì¥ì‹œê°„, ì‘ì„±ì
               FROM work_log WHERE {where_clause}
               ORDER BY ë‚ ì§œ DESC, id DESC LIMIT ?""",
            params + [limit]
        ).fetchall()
        
        logs = [
            {"id": r[0], "ë‚ ì§œ": r[1], "ì—…ì²´ëª…": r[2], "ë¶„ë¥˜": r[3], "ìˆ˜ëŸ‰": r[4],
             "ë‹¨ê°€": r[5], "í•©ê³„": r[6], "ì €ì¥ì‹œê°„": str(r[7]) if r[7] else None, "ì‘ì„±ì": r[8]}
            for r in rows
        ]
        
        total_amount = sum(l["í•©ê³„"] or 0 for l in logs)
    
    return {
        "success": True,
        "count": len(logs),
        "total_amount": total_amount,
        "logs": logs,
        "message": f"ê²€ìƒ‰ê²°ê³¼: {len(logs)}ê±´, ì´ {total_amount:,}ì›"
    }


def _get_work_log_stats(args: Dict, user_id: str, user_name: str) -> Dict:
    """ì‘ì—…ì¼ì§€ í†µê³„"""
    conditions = []
    params = []
    
    if args.get("start_date"):
        conditions.append("ë‚ ì§œ >= ?")
        params.append(args["start_date"])
    if args.get("end_date"):
        conditions.append("ë‚ ì§œ <= ?")
        params.append(args["end_date"])
    if args.get("vendor"):
        conditions.append("ì—…ì²´ëª… LIKE ?")
        params.append(f"%{args['vendor']}%")
    
    where_clause = " AND ".join(conditions) if conditions else "1=1"
    
    with get_connection() as con:
        # ì´í•©
        total_row = con.execute(
            f"SELECT COUNT(*), COALESCE(SUM(í•©ê³„), 0) FROM work_log WHERE {where_clause}",
            params
        ).fetchone()
        
        # ì—…ì²´ë³„
        by_vendor = con.execute(
            f"""SELECT ì—…ì²´ëª…, COUNT(*), SUM(í•©ê³„)
               FROM work_log WHERE {where_clause} AND ì—…ì²´ëª… IS NOT NULL
               GROUP BY ì—…ì²´ëª… ORDER BY SUM(í•©ê³„) DESC LIMIT 10""",
            params
        ).fetchall()
        
        # ì‘ì—…ì¢…ë¥˜ë³„
        by_work_type = con.execute(
            f"""SELECT ë¶„ë¥˜, COUNT(*), SUM(í•©ê³„)
               FROM work_log WHERE {where_clause} AND ë¶„ë¥˜ IS NOT NULL
               GROUP BY ë¶„ë¥˜ ORDER BY COUNT(*) DESC LIMIT 10""",
            params
        ).fetchall()
    
    return {
        "success": True,
        "total_count": total_row[0] or 0,
        "total_amount": total_row[1] or 0,
        "by_vendor": [{"vendor": v[0], "count": v[1], "amount": v[2]} for v in by_vendor],
        "by_work_type": [{"work_type": w[0], "count": w[1], "amount": w[2]} for w in by_work_type],
        "message": f"í†µê³„: {total_row[0]}ê±´, ì´ {total_row[1]:,}ì›"
    }


def _compare_periods(args: Dict, user_id: str, user_name: str) -> Dict:
    """ê¸°ê°„ ë¹„êµ"""
    stats1 = _get_work_log_stats({
        "start_date": args.get("period1_start"),
        "end_date": args.get("period1_end")
    }, user_id, user_name)
    
    stats2 = _get_work_log_stats({
        "start_date": args.get("period2_start"),
        "end_date": args.get("period2_end")
    }, user_id, user_name)
    
    count_diff = stats2["total_count"] - stats1["total_count"]
    amount_diff = stats2["total_amount"] - stats1["total_amount"]
    count_rate = (count_diff / stats1["total_count"] * 100) if stats1["total_count"] > 0 else 0
    amount_rate = (amount_diff / stats1["total_amount"] * 100) if stats1["total_amount"] > 0 else 0
    
    return {
        "success": True,
        "period1": {
            "name": args.get("period1_name", "ê¸°ê°„1"),
            "start": args.get("period1_start"),
            "end": args.get("period1_end"),
            "count": stats1["total_count"],
            "amount": stats1["total_amount"]
        },
        "period2": {
            "name": args.get("period2_name", "ê¸°ê°„2"),
            "start": args.get("period2_start"),
            "end": args.get("period2_end"),
            "count": stats2["total_count"],
            "amount": stats2["total_amount"]
        },
        "diff": {
            "count": count_diff,
            "count_rate": count_rate,
            "amount": amount_diff,
            "amount_rate": amount_rate
        },
        "message": f"ë¹„êµ: ê±´ìˆ˜ {count_diff:+}ê±´({count_rate:+.1f}%), ê¸ˆì•¡ {amount_diff:+,}ì›({amount_rate:+.1f}%)"
    }


def _update_work_log(args: Dict, user_id: str, user_name: str) -> Dict:
    """ì‘ì—…ì¼ì§€ ìˆ˜ì •"""
    log_id = args.get("log_id")
    update_recent = args.get("update_recent", False)
    
    with get_connection() as con:
        # ìˆ˜ì •í•  ë ˆì½”ë“œ ì°¾ê¸°
        if update_recent:
            row = con.execute(
                """SELECT id, ë‚ ì§œ, ì—…ì²´ëª…, ë¶„ë¥˜, ë‹¨ê°€, ìˆ˜ëŸ‰, í•©ê³„
                   FROM work_log WHERE works_user_id = ?
                   ORDER BY id DESC LIMIT 1""",
                (user_id,)
            ).fetchone()
        elif log_id:
            row = con.execute(
                "SELECT id, ë‚ ì§œ, ì—…ì²´ëª…, ë¶„ë¥˜, ë‹¨ê°€, ìˆ˜ëŸ‰, í•©ê³„ FROM work_log WHERE id = ?",
                (log_id,)
            ).fetchone()
        else:
            # ì¡°ê±´ìœ¼ë¡œ ì°¾ê¸°
            conditions = ["works_user_id = ?"]
            params = [user_id]
            if args.get("vendor"):
                conditions.append("ì—…ì²´ëª… LIKE ?")
                params.append(f"%{args['vendor']}%")
            if args.get("date"):
                conditions.append("ë‚ ì§œ = ?")
                params.append(args["date"])
            if args.get("old_price"):
                conditions.append("í•©ê³„ BETWEEN ? AND ?")
                params.extend([int(args["old_price"] * 0.9), int(args["old_price"] * 1.1)])
            
            row = con.execute(
                f"""SELECT id, ë‚ ì§œ, ì—…ì²´ëª…, ë¶„ë¥˜, ë‹¨ê°€, ìˆ˜ëŸ‰, í•©ê³„
                   FROM work_log WHERE {' AND '.join(conditions)}
                   ORDER BY id DESC LIMIT 1""",
                params
            ).fetchone()
        
        if not row:
            return {"success": False, "error": "ìˆ˜ì •í•  ì‘ì—…ì¼ì§€ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."}
        
        log_id = row[0]
        old_data = {
            "ë‚ ì§œ": row[1], "ì—…ì²´ëª…": row[2], "ë¶„ë¥˜": row[3],
            "ë‹¨ê°€": row[4], "ìˆ˜ëŸ‰": row[5], "í•©ê³„": row[6]
        }
        
        # ì—…ë°ì´íŠ¸ í•„ë“œ êµ¬ì„±
        updates = []
        update_params = []
        
        if args.get("new_vendor"):
            updates.append("ì—…ì²´ëª… = ?")
            update_params.append(args["new_vendor"])
        if args.get("new_work_type"):
            updates.append("ë¶„ë¥˜ = ?")
            update_params.append(args["new_work_type"])
        if args.get("new_unit_price"):
            updates.append("ë‹¨ê°€ = ?")
            update_params.append(args["new_unit_price"])
        if args.get("new_qty"):
            updates.append("ìˆ˜ëŸ‰ = ?")
            update_params.append(args["new_qty"])
        
        if not updates:
            return {"success": False, "error": "ìˆ˜ì •í•  ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤."}
        
        # í•©ê³„ ì¬ê³„ì‚°
        new_ë‹¨ê°€ = args.get("new_unit_price") or old_data["ë‹¨ê°€"]
        new_ìˆ˜ëŸ‰ = args.get("new_qty") or old_data["ìˆ˜ëŸ‰"]
        updates.append("í•©ê³„ = ?")
        update_params.append(new_ë‹¨ê°€ * new_ìˆ˜ëŸ‰)
        
        update_params.append(log_id)
        con.execute(f"UPDATE work_log SET {', '.join(updates)} WHERE id = ?", update_params)
        con.commit()
        
        # ìˆ˜ì •ëœ ë°ì´í„° ì¡°íšŒ
        new_row = con.execute(
            "SELECT ë‚ ì§œ, ì—…ì²´ëª…, ë¶„ë¥˜, ë‹¨ê°€, ìˆ˜ëŸ‰, í•©ê³„ FROM work_log WHERE id = ?",
            (log_id,)
        ).fetchone()
        
        new_data = {
            "ë‚ ì§œ": new_row[0], "ì—…ì²´ëª…": new_row[1], "ë¶„ë¥˜": new_row[2],
            "ë‹¨ê°€": new_row[3], "ìˆ˜ëŸ‰": new_row[4], "í•©ê³„": new_row[5]
        }
    
    # ì´ë ¥ ê¸°ë¡
    _log_work_history(log_id, "update", new_data, user_name, "ìˆ˜ì •", user_id)
    
    return {
        "success": True,
        "log_id": log_id,
        "old_data": old_data,
        "new_data": new_data,
        "message": f"ìˆ˜ì •ì™„ë£Œ! {new_data['ì—…ì²´ëª…']} {new_data['ë¶„ë¥˜']} {new_data['í•©ê³„']:,}ì›"
    }


def _bulk_update_work_logs(args: Dict, user_id: str, user_name: str) -> Dict:
    """ì¼ê´„ ìˆ˜ì •"""
    new_unit_price = args.get("new_unit_price")
    if not new_unit_price:
        return {"success": False, "error": "ìƒˆ ë‹¨ê°€ë¥¼ ì§€ì •í•´ì£¼ì„¸ìš”."}
    
    conditions = ["works_user_id = ?"]
    params = [user_id]
    
    if args.get("vendor"):
        conditions.append("ì—…ì²´ëª… LIKE ?")
        params.append(f"%{args['vendor']}%")
    if args.get("work_type"):
        conditions.append("ë¶„ë¥˜ LIKE ?")
        params.append(f"%{args['work_type']}%")
    if args.get("date"):
        conditions.append("ë‚ ì§œ = ?")
        params.append(args["date"])
    if args.get("start_date"):
        conditions.append("ë‚ ì§œ >= ?")
        params.append(args["start_date"])
    if args.get("end_date"):
        conditions.append("ë‚ ì§œ <= ?")
        params.append(args["end_date"])
    
    with get_connection() as con:
        cursor = con.execute(
            f"""UPDATE work_log 
               SET ë‹¨ê°€ = ?, í•©ê³„ = ìˆ˜ëŸ‰ * ?
               WHERE {' AND '.join(conditions)}""",
            [new_unit_price, new_unit_price] + params
        )
        con.commit()
        updated_count = cursor.rowcount
    
    return {
        "success": True,
        "updated_count": updated_count,
        "new_unit_price": new_unit_price,
        "message": f"{updated_count}ê±´ ì¼ê´„ ìˆ˜ì •ì™„ë£Œ! ë‹¨ê°€: {new_unit_price:,}ì›"
    }


def _copy_work_logs(args: Dict, user_id: str, user_name: str) -> Dict:
    """ì‘ì—…ì¼ì§€ ë³µì‚¬"""
    target_date = args.get("target_date") or datetime.now().strftime("%Y-%m-%d")
    
    conditions = []
    params = []
    
    if args.get("source_date"):
        conditions.append("ë‚ ì§œ = ?")
        params.append(args["source_date"])
    if args.get("source_start_date") and args.get("source_end_date"):
        conditions.append("ë‚ ì§œ >= ? AND ë‚ ì§œ <= ?")
        params.extend([args["source_start_date"], args["source_end_date"]])
    if args.get("vendor"):
        conditions.append("ì—…ì²´ëª… LIKE ?")
        params.append(f"%{args['vendor']}%")
    
    if not conditions:
        return {"success": False, "error": "ë³µì‚¬í•  ì›ë³¸ ì¡°ê±´ì„ ì§€ì •í•´ì£¼ì„¸ìš”."}
    
    new_ids = []
    ì €ì¥ì‹œê°„ = datetime.now().isoformat()
    
    with get_connection() as con:
        rows = con.execute(
            f"""SELECT ì—…ì²´ëª…, ë¶„ë¥˜, ë‹¨ê°€, ìˆ˜ëŸ‰, í•©ê³„, ë¹„ê³ 1, ì‘ì„±ì, ì¶œì²˜, works_user_id
               FROM work_log WHERE {' AND '.join(conditions)}""",
            params
        ).fetchall()
        
        for row in rows:
            cursor = con.execute(
                """INSERT INTO work_log (ë‚ ì§œ, ì—…ì²´ëª…, ë¶„ë¥˜, ë‹¨ê°€, ìˆ˜ëŸ‰, í•©ê³„, ë¹„ê³ 1, ì‘ì„±ì, ì €ì¥ì‹œê°„, ì¶œì²˜, works_user_id)
                   VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (target_date, row[0], row[1], row[2], row[3], row[4],
                 f"{row[5] or ''} [ë³µì‚¬ë¨]", row[6], ì €ì¥ì‹œê°„, "bot_copy", row[8])
            )
            new_ids.append(cursor.lastrowid)
        
        con.commit()
    
    return {
        "success": True,
        "copied_count": len(new_ids),
        "target_date": target_date,
        "new_ids": new_ids,
        "message": f"{len(new_ids)}ê±´ ë³µì‚¬ì™„ë£Œ! ëŒ€ìƒ ë‚ ì§œ: {target_date}"
    }


def _add_memo(args: Dict, user_id: str, user_name: str) -> Dict:
    """ë©”ëª¨ ì¶”ê°€"""
    memo = args.get("memo", "")
    if not memo:
        return {"success": False, "error": "ë©”ëª¨ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”."}
    
    log_id = args.get("log_id")
    add_to_recent = args.get("add_to_recent", False)
    
    with get_connection() as con:
        if add_to_recent or not log_id:
            row = con.execute(
                "SELECT id FROM work_log WHERE works_user_id = ? ORDER BY id DESC LIMIT 1",
                (user_id,)
            ).fetchone()
            if row:
                log_id = row[0]
        
        if not log_id:
            return {"success": False, "error": "ë©”ëª¨ë¥¼ ì¶”ê°€í•  ì‘ì—…ì¼ì§€ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."}
        
        existing = con.execute("SELECT ë¹„ê³ 1 FROM work_log WHERE id = ?", (log_id,)).fetchone()
        if existing:
            old_memo = existing[0] or ""
            new_memo = f"{old_memo} [{memo}]" if old_memo else memo
            con.execute("UPDATE work_log SET ë¹„ê³ 1 = ? WHERE id = ?", (new_memo, log_id))
            con.commit()
    
    return {
        "success": True,
        "log_id": log_id,
        "memo": memo,
        "message": f"ë©”ëª¨ ì¶”ê°€ì™„ë£Œ! [{memo}]"
    }


def _get_undo_history(args: Dict, user_id: str, user_name: str) -> Dict:
    """ë³€ê²½ ì´ë ¥ ì¡°íšŒ"""
    limit = args.get("limit", 5)
    
    with get_connection() as con:
        rows = con.execute(
            """SELECT id, action, ì—…ì²´ëª…, ë¶„ë¥˜, í•©ê³„, ë³€ê²½ì, ë³€ê²½ì‹œê°„, log_id
               FROM work_log_history
               WHERE works_user_id = ?
               ORDER BY id DESC LIMIT ?""",
            (user_id, limit)
        ).fetchall()
    
    history = []
    for i, r in enumerate(rows, 1):
        history.append({
            "index": i,
            "id": r[0],
            "action": r[1],
            "vendor": r[2],
            "work_type": r[3],
            "amount": r[4],
            "user": r[5],
            "time": r[6],
            "log_id": r[7]
        })
    
    return {
        "success": True,
        "history": history,
        "message": f"ìµœê·¼ ë³€ê²½ ì´ë ¥ {len(history)}ê±´"
    }


def _undo_action(args: Dict, user_id: str, user_name: str) -> Dict:
    """ë˜ëŒë¦¬ê¸° ì‹¤í–‰"""
    history_id = args.get("history_id")
    history_index = args.get("history_index")
    
    # ì´ë ¥ ì¡°íšŒ
    history_result = _get_undo_history({"limit": 10}, user_id, user_name)
    history = history_result.get("history", [])
    
    if not history:
        return {"success": False, "error": "ë˜ëŒë¦´ ì´ë ¥ì´ ì—†ìŠµë‹ˆë‹¤."}
    
    # ëŒ€ìƒ ì°¾ê¸°
    target = None
    if history_index:
        for h in history:
            if h["index"] == history_index:
                target = h
                break
    elif history_id:
        for h in history:
            if h["id"] == history_id:
                target = h
                break
    
    if not target:
        return {"success": False, "error": "ë˜ëŒë¦´ ì´ë ¥ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤."}
    
    action = target["action"]
    log_id = target["log_id"]
    
    if action == "create":
        # ìƒì„±ëœ ê²ƒ ì‚­ì œ
        with get_connection() as con:
            con.execute("DELETE FROM work_log WHERE id = ?", (log_id,))
            con.commit()
        return {"success": True, "message": "ë˜ëŒë¦¬ê¸° ì™„ë£Œ! (ì¶”ê°€ëœ ë°ì´í„° ì‚­ì œë¨)"}
    
    elif action == "delete":
        # ì‚­ì œëœ ê²ƒ ë³µêµ¬
        data = {
            "vendor": target["vendor"],
            "work_type": target["work_type"],
            "unit_price": target["amount"],  # í•©ê³„ë¥¼ ë‹¨ê°€ë¡œ ì‚¬ìš© (ìˆ˜ëŸ‰ 1 ê°€ì •)
            "qty": 1,
            "remark": "[ë³µêµ¬ë¨]"
        }
        result = _save_work_log(data, user_id, user_name)
        return {"success": True, "message": "ë˜ëŒë¦¬ê¸° ì™„ë£Œ! (ì‚­ì œëœ ë°ì´í„° ë³µêµ¬ë¨)", "new_id": result.get("record_id")}
    
    return {"success": False, "error": "ì´ í•­ëª©ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."}


def _get_dashboard_url(args: Dict, user_id: str, user_name: str) -> Dict:
    """ëŒ€ì‹œë³´ë“œ URL"""
    import os
    base_url = os.getenv("FRONTEND_URL", "https://my-streamlit-app-2.vercel.app")
    
    return {
        "success": True,
        "urls": {
            "main": base_url,
            "work_log": f"{base_url}/work-log"
        },
        "message": f"ëŒ€ì‹œë³´ë“œ: {base_url}"
    }


def _web_search(args: Dict, user_id: str, user_name: str) -> Dict:
    """ì›¹ ê²€ìƒ‰"""
    query = args.get("query", "")
    if not query:
        return {"success": False, "error": "ê²€ìƒ‰ì–´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”."}
    
    try:
        from duckduckgo_search import DDGS
        
        results = []
        with DDGS() as ddgs:
            for r in ddgs.text(query, max_results=5):
                results.append({
                    "title": r.get("title", ""),
                    "url": r.get("href", ""),
                    "snippet": r.get("body", "")
                })
        
        if not results:
            return {"success": False, "error": "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤."}
        
        return {
            "success": True,
            "query": query,
            "results": results,
            "message": f"'{query}' ê²€ìƒ‰ê²°ê³¼ {len(results)}ê±´"
        }
    except ImportError:
        return {"success": False, "error": "ì›¹ ê²€ìƒ‰ ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."}
    except Exception as e:
        return {"success": False, "error": str(e)}


def _get_help(args: Dict, user_id: str, user_name: str) -> Dict:
    """ë„ì›€ë§"""
    topic = args.get("topic", "ì „ì²´")
    
    help_texts = {
        "ì…ë ¥": """ğŸ“ ì‘ì—…ì¼ì§€ ì…ë ¥
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
âœ¨ ìì—°ìŠ¤ëŸ½ê²Œ ë§í•˜ë©´ ë©ë‹ˆë‹¤!

â€¢ "í‹¸ë¦¬ì–¸ 1í†¤í•˜ì°¨ 3ë§Œì›"
â€¢ "ë‚˜ë¸”ë¦¬ ì–‘í’ˆí™” 20ê°œ 800ì›"
â€¢ "ì–´ì œ í‹¸ë¦¬ì–¸ í•˜ì°¨ 3ë§Œì›"

ğŸ’¬ ì •ë³´ê°€ ë¶€ì¡±í•˜ë©´ ë¬¼ì–´ë´ìš”:
  "í‹¸ë¦¬ì–¸ í•˜ì°¨" â†’ "ë‹¨ê°€ê°€ ì–¼ë§ˆì˜ˆìš”?"
  "3ë§Œì›" â†’ ìë™ìœ¼ë¡œ ì™„ì„±!

ğŸ’¡ ì…ë ¥ í›„ 'ì·¨ì†Œ'ë¡œ ë°”ë¡œ ì‚­ì œ ê°€ëŠ¥""",

        "ì¡°íšŒ": """ğŸ” ì¡°íšŒ/ê²€ìƒ‰
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ìì—°ì–´ë¡œ ë¬¼ì–´ë³´ì„¸ìš”!

ğŸ“… ê¸°ê°„ ì¡°íšŒ
â€¢ "ì˜¤ëŠ˜ ì‘ì—… ë³´ì—¬ì¤˜"
â€¢ "ì´ë²ˆì£¼ ë­í–ˆì–´?"
â€¢ "ì§€ë‚œë‹¬ ì‘ì—…"

ğŸ¢ ì—…ì²´ë³„ ì¡°íšŒ
â€¢ "í‹¸ë¦¬ì–¸ ì‘ì—… ë³´ì—¬ì¤˜"
â€¢ "ì´ë²ˆì£¼ ë‚˜ë¸”ë¦¬"

ğŸ’° ê¸ˆì•¡ ê²€ìƒ‰
â€¢ "3ë§Œì›ì§œë¦¬ ë­ìˆì–´?"
â€¢ "5ë§Œì› ì´ìƒ"

ğŸ”€ ì¡°í•©ë„ ê°€ëŠ¥!
â€¢ "ì´ë²ˆì£¼ í‹¸ë¦¬ì–¸ ë­í–ˆì–´?"
â€¢ "ì–´ì œ 3ë§Œì›ì§œë¦¬"

ğŸ“¥ ê²°ê³¼ì—ì„œ ì—‘ì…€ ë‹¤ìš´ë¡œë“œ ê°€ëŠ¥""",

        "ìˆ˜ì •": """âœï¸ ìˆ˜ì •/ì‚­ì œ
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ—‘ï¸ ì‚­ì œ
â€¢ "ì·¨ì†Œ" / "ì‚­ì œí•´ì¤˜"
â€¢ "ë°©ê¸ˆêº¼ ì§€ì›Œì¤˜"
â€¢ "í‹¸ë¦¬ì–¸ 3ë§Œì› ì‚­ì œí•´ì¤˜"

âœï¸ ìˆ˜ì •
â€¢ "ìˆ˜ì •í•´ì¤˜"
â€¢ "5ë§Œì›ìœ¼ë¡œ ë°”ê¿”ì¤˜"
â€¢ "ì—…ì²´ëª… í‹¸ë¦¬ì–¸ìœ¼ë¡œ ìˆ˜ì •"

ğŸ“¦ ì¼ê´„ ìˆ˜ì •
â€¢ "ì˜¤ëŠ˜ ì „ë¶€ 5ë§Œì›ìœ¼ë¡œ"
â€¢ "í‹¸ë¦¬ì–¸ ë‹¨ê°€ 3ë§Œì›ìœ¼ë¡œ"

ğŸ”„ ë˜ëŒë¦¬ê¸°
â€¢ "ë˜ëŒë ¤ì¤˜" - ìµœê·¼ ë³€ê²½ ì´ë ¥
â€¢ ë²ˆí˜¸ ì„ íƒí•´ì„œ ë³µêµ¬""",

        "ë¶„ì„": """ğŸ“Š í†µê³„/ë¶„ì„
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ’° í•©ê³„
â€¢ "ì´ë²ˆë‹¬ ì´ ì–¼ë§ˆ?"
â€¢ "ì˜¤ëŠ˜ í•©ê³„"

ğŸ¢ ì—…ì²´ë³„
â€¢ "ì—…ì²´ë³„ í•©ê³„"
â€¢ "í‹¸ë¦¬ì–¸ ì´ë²ˆë‹¬ ì–¼ë§ˆ?"

ğŸ“ˆ ë¹„êµ
â€¢ "ì§€ë‚œì£¼ë‘ ì´ë²ˆì£¼ ë¹„êµ"
â€¢ "ì €ë²ˆë‹¬ì´ë‘ ë¹„êµí•´ì¤˜"

ğŸ† ìˆœìœ„
â€¢ "ê°€ì¥ ë§ì´ ì¼í•œ ì—…ì²´"
â€¢ "ì´ë²ˆë‹¬ Top 5"

ğŸŒ ëŒ€ì‹œë³´ë“œ
â€¢ "ëŒ€ì‹œë³´ë“œ" â†’ ì›¹ ë§í¬ ì œê³µ""",

        "ê³ ê¸‰": """ğŸ”§ ê³ ê¸‰ ê¸°ëŠ¥
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“‹ ë©”ëª¨ ì¶”ê°€
â€¢ "ë°©ê¸ˆêº¼ì— ë©”ëª¨ ì¶”ê°€í•´ì¤˜"
â€¢ "ê¸‰ê±´ì´ë¼ê³  ë©”ëª¨"

ğŸ“‘ ë³µì‚¬
â€¢ "ì–´ì œêº¼ ì˜¤ëŠ˜ë¡œ ë³µì‚¬"
â€¢ "ì›”ìš”ì¼ ì‘ì—… ë³µì‚¬í•´ì¤˜"

ğŸ“Š ì—‘ì…€ ì¼ê´„ ë“±ë¡
â€¢ ì—‘ì…€ íŒŒì¼ ë³´ë‚´ë©´ ìë™ ë“±ë¡
â€¢ í•„ìˆ˜ ì»¬ëŸ¼: ë‚ ì§œ, ì—…ì²´ëª…, ë¶„ë¥˜, ë‹¨ê°€

ğŸ” ì›¹ ê²€ìƒ‰
â€¢ "OOì—…ì²´ ì •ë³´ ì°¾ì•„ì¤˜"

ğŸ’¬ ì¼ë°˜ ëŒ€í™”
â€¢ ì•„ë¬´ ì§ˆë¬¸ì´ë‚˜ OK!
â€¢ AIê°€ ì´í•´í•˜ê³  ë‹µë³€í•´ìš”""",

        "ì „ì²´": """ğŸ“š ì‘ì—…ì¼ì§€ë´‡ ì‚¬ìš©ë²•
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¬ ìì—°ì–´ë¡œ í¸í•˜ê²Œ ë§í•˜ì„¸ìš”!
ì •ë³´ê°€ ë¶€ì¡±í•˜ë©´ ë¬¼ì–´ë³´ê³ ,
ëŒ€í™”í•˜ë“¯ ì™„ì„±í•´ê°‘ë‹ˆë‹¤.

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ ì…ë ¥ ì˜ˆì‹œ
  "í‹¸ë¦¬ì–¸ í•˜ì°¨ 3ë§Œì›"
  "ë‚˜ë¸”ë¦¬ ì–‘í’ˆí™” 20ê°œ 800ì›"

ğŸ” ì¡°íšŒ ì˜ˆì‹œ
  "ì˜¤ëŠ˜ ì‘ì—… ë³´ì—¬ì¤˜"
  "ì´ë²ˆì£¼ í‹¸ë¦¬ì–¸"

âœï¸ ìˆ˜ì • ì˜ˆì‹œ
  "ì·¨ì†Œ" / "ìˆ˜ì •í•´ì¤˜"
  "5ë§Œì›ìœ¼ë¡œ ë°”ê¿”"

ğŸ“Š í†µê³„ ì˜ˆì‹œ
  "ì´ë²ˆë‹¬ ì´ ì–¼ë§ˆ?"
  "ì§€ë‚œì£¼ë‘ ë¹„êµ"

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“– ìƒì„¸ ë„ì›€ë§
  "ë„ì›€ë§ ì…ë ¥"
  "ë„ì›€ë§ ì¡°íšŒ"
  "ë„ì›€ë§ ìˆ˜ì •"
  "ë„ì›€ë§ ë¶„ì„"
  "ë„ì›€ë§ ê³ ê¸‰"
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"""
    }
    
    return {
        "success": True,
        "topic": topic,
        "help_text": help_texts.get(topic, help_texts["ì „ì²´"]),
        "message": f"ë„ì›€ë§: {topic}"
    }


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def _log_work_history(
    log_id: int,
    action: str,
    log_data: Dict,
    ë³€ê²½ì: str = None,
    ë³€ê²½ì‚¬ìœ : str = None,
    works_user_id: str = None
):
    """ì‘ì—…ì¼ì§€ ë³€ê²½ ì´ë ¥ ê¸°ë¡"""
    try:
        with get_connection() as con:
            con.execute(
                """INSERT INTO work_log_history 
                   (log_id, action, ë‚ ì§œ, ì—…ì²´ëª…, ë¶„ë¥˜, ë‹¨ê°€, ìˆ˜ëŸ‰, í•©ê³„, ì‘ì„±ì, ë³€ê²½ì, ë³€ê²½ì‹œê°„, ë³€ê²½ì‚¬ìœ , works_user_id)
                   VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
                (
                    log_id, action,
                    log_data.get("ë‚ ì§œ") or log_data.get("date"),
                    log_data.get("ì—…ì²´ëª…") or log_data.get("vendor"),
                    log_data.get("ë¶„ë¥˜") or log_data.get("work_type"),
                    log_data.get("ë‹¨ê°€") or log_data.get("unit_price"),
                    log_data.get("ìˆ˜ëŸ‰") or log_data.get("qty"),
                    log_data.get("í•©ê³„") or (log_data.get("ìˆ˜ëŸ‰", 1) * log_data.get("ë‹¨ê°€", 0)),
                    log_data.get("ì‘ì„±ì"),
                    ë³€ê²½ì,
                    datetime.now().isoformat(),
                    ë³€ê²½ì‚¬ìœ ,
                    works_user_id
                )
            )
            con.commit()
    except Exception as e:
        print(f"Warning: Could not log work history: {e}")


def get_db_context_for_ai() -> str:
    """AIì—ê²Œ ì œê³µí•  DB ì»¨í…ìŠ¤íŠ¸ ìš”ì•½"""
    try:
        today = datetime.now()
        month_start = today.replace(day=1).strftime("%Y-%m-%d")
        month_end = today.strftime("%Y-%m-%d")
        
        with get_connection() as con:
            # ë“±ë¡ ì—…ì²´
            vendors = [r[0] for r in con.execute(
                "SELECT vendor FROM vendors WHERE active != 'NO' OR active IS NULL ORDER BY vendor LIMIT 15"
            ).fetchall() if r[0]]
            
            # ìì£¼ ì“°ëŠ” ì‘ì—…ì¢…ë¥˜
            work_types = [r[0] for r in con.execute(
                """SELECT ë¶„ë¥˜ FROM work_log WHERE ë¶„ë¥˜ IS NOT NULL
                   GROUP BY ë¶„ë¥˜ ORDER BY COUNT(*) DESC LIMIT 10"""
            ).fetchall() if r[0]]
            
            # ì´ë²ˆë‹¬ í†µê³„
            stats = con.execute(
                f"SELECT COUNT(*), COALESCE(SUM(í•©ê³„), 0) FROM work_log WHERE ë‚ ì§œ BETWEEN ? AND ?",
                (month_start, month_end)
            ).fetchone()
        
        context = f"""## í˜„ì¬ DB ì •ë³´
- ë“±ë¡ ì—…ì²´: {', '.join(vendors[:10])}{'...' if len(vendors) > 10 else ''}
- ìì£¼ ì“°ëŠ” ì‘ì—…: {', '.join(work_types)}
- ì´ë²ˆë‹¬: {stats[0]}ê±´, {stats[1]:,}ì› ({month_start} ~ {month_end})
- ì˜¤ëŠ˜: {today.strftime('%Y-%m-%d')} ({today.strftime('%A')})"""
        
        return context
    except Exception as e:
        return f"## DB ì •ë³´ ë¡œë“œ ì˜¤ë¥˜: {e}"
